---
title: "MySQL：MVCC"
date: 2021-05-05T21:30:02+08:00
categories:
- 学习笔记
- mysql
tags:
- mysql实现原理
keywords:
- MySQL多版本控制
- MVCC
comments: false
summary: MVCC是MySQL多版本并发控制（Multi-Version Concurrency Control）的缩写。同文浅谈MVCC如何基于版本而不是基于锁来实现并发控制。
#thumbnailImage: //example.com/image.jpg
---

<!--more-->

### 实现原理

innoDB的行记录格式中有6字节事务ID的和7字节的回滚指针，通过为每一行记录添加这两个额外的隐藏值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。

但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。

当隔离级别是REPEATABLE READ时这种策略是如何应用到特定的操作的。

**SELECT**

当隔离级别是REPEATABLE READ时select操作，InnoDB必须每行数据来保证它符合两个条件：

1. InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。
2. 这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。
   符合这两个条件的行可能会被当作查询结果而返回。

**INSERT**

InnoDB为这个新行记录当前的系统版本号。

**DELETE**

InnoDB将当前的系统版本号设置为这一行的删除ID。

**UPDATE**

InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。

当记录不满足SELECT的第一个条件时，就读取它的历史版本，而具有回滚作用的`undo log`就在这里用上了。

### 优缺点

这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。

### 兼容性

MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。



