---
title: "Redis（四）：跳跃表"
date: 2021-03-11T21:26:55+08:00
categories:
- 学习笔记
- Redis
tags:
- Redis数据结构与对象
keywords:
- redis
- 跳跃表
comments: false
#cover: images/host/redis/redis-icon-logo.png
summary: Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。本文分析了redis跳跃表的实现和特点。
---

<!--more-->

跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，而且实现还更加简单。

##### 跳跃表结构解析

![跳跃表结构示意图](/images/host/redis/redis-zskip.jpg)

- `header`：指向跳跃表的表头节点。

- `tail`：指向跳跃表的表尾节点。

- `level`：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。

- `length`：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。

首先要注意的是跳表是有序的，从结构示意图中可以看到节点按`score`（即图中的1.0、2.0、3.0）从小到大排列，离表头越远，`score`越大。

重点是节点的结构，节点包含的属性可以分为两部分讲，一部分用来跳跃，一部分用来保存对象。

跳跃可以按方向分为两种：向表尾跳和向表头跳，分别通过**层**和**后退指针**完成。

结构示意图中L1、L2、L3 …代表的就是层，可以看到一个节点的层不止一个，高层跳的远（跨度大），低层跳的近（跨度小）。而后退指针只有一个（图中的BW），所以只能以固定的跨度1向表头跳。

###### 查找节点

以升序表为例，查找节点的流程如下：

1. 找到表头节点顶层

2. 比较当前层下一节点（层指针指向的节点）和目标节点
    - 如果相等，找到节点，流程结束
    - 如果小于目标节点，那么跳到下一节点的当前层，重复步骤2
    - 如果大于目标节点或者到了表尾（指向null），那么跳到当前节点的下一层，重复步骤2

如果无法再重复步骤2还没找到节点，说明节点不存在。要注意的是由于Redis允许重复的score值，所以进行对比操作时，不仅要检查 score 值，还要检查 member域。

查找节点的复杂度平均**O(logN)**，最坏**O(N)**。

##### 插入节点

1. 找到要插入的位置，为其插入第一层。
2. 通过指定的概率p和随机算法确定是否插入第N层，N不大于最大层数，默认32。

如果概率p为0.5，那么可以用抛硬币来类比这个过程，如果是正面插入一层，然后再抛，否则退出。

可以推导出如果p越大，那么高层节点越多，查找节点越快，占用空间越多。

插入新节点复杂度平均 **O(logN)**，最坏**O(N)** 。

##### 删除节点

相比之下，删除节点操作较为简单，和单链表删除节点所做操作大体相同。删除节点的复杂度也是平均 **O(logN)**，最坏**O(N)**。删除分为内节点复杂度为**O(N)**，N为删除节点数量。

##### 总结

redis跳跃表以一种较为简单的方式实现和平衡树相同的效率，基本原理是建立一些“捷径”，免于逐节点比对。但是由于捷径是随机产生的，稳定性上还是不如平衡树。

