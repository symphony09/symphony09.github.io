---
title: "Redis（一）：SDS"
date: 2021-03-06T00:24:45+08:00
categories:
- 学习笔记
- Redis
tags:
- Redis数据结构与对象
keywords:
- redis
- sds
comments: false
#thumbnailImage: images/host/redis/redis-icon-logo.png
summary: Sds （Simple Dynamic String，简单动态字符串）是 Redis 底层所使用的字符串表示， 几乎所有的 Redis 模块中都用了 sds。本文将对 sds 的实现、性能和功能等方面进行介绍， 并说明 Redis 使用 sds 而不是传统 C 字符串的原因。
---

<!--more-->

Redis 是 C 语言实现的，但是 Redis 放弃了 C 语言传统的字符串而是自己创建了一种名为}简单动态字符串 SDS（Simple Dynamic String）的抽象类型，并将 SDS 用作 Redis 的默认字符串表示，其主要原因就是传统的字符串表示方式并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求。先来看看SDS长什么样吧

##### SDS 数据结构示意图：

![sds结构示意图](/images/host/redis/redis-sds.png)

可以看到字符串`"redis"`以字符数组的形式存放在了`buf`中，空字符`'\0'`表示字符串结尾，这一点和C语言的字符串是一样的。而多出来的`len`，`alloc`，`flags`让SDS**更安全、性能更好、功能性更强**，具体来说就是：

1. **可以常数复杂度获取字符串长度**。
2. **杜绝缓冲区溢出。**
3. **减少修改字符串长度时所需的内存重分配次数。**
4. **二进制安全。**
5. **兼容部分C字符串函数。**

下面就来逐条分析SDS是怎么做到这几点的。

##### 一、 常数复杂度获取字符串长度

C语言字符串没有记录自身的长度信息，所以要获取字符串长度时，就要从头开始挨个读字符，直到读取到意味着结尾的空字符`'\0'`, 复杂度为**O(n)**。而SDS把长度信息记录在了`len`字段，需要获取字符串长度时直接读`len`的值就OK了，复杂度降到了**O(1)**。

##### 二、 杜绝缓冲区溢出

缓冲区溢出（buffer overflow）是指当程序将数据写入缓冲区并且数据过长时，会超过缓冲区的边界，并覆盖相邻的内存位置而造成的异常。C字符串会有缓冲区溢出的风险同样是因为没有记录自身长度，不会自动进行边界检查。而SDS就不会粗暴地把大象塞进冰箱。

当SDS要进行修改时，Redis首先会检查SDS的空间是否满足修改所需的要求，如果不满足的话，就会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。

##### 三、减小修改字符串长度时所需的内存重分配次数

上一节提到SDS会视情况扩展空间，这涉及到了重新分配内存，然而频繁分配内存会显著影响性能，这可不行。SDS通过空间预分配和惰性空间释放两种优化策略减小修改字符串长度时所需的内存重分配次数。

###### 1）空间预分配

空间预分配用于优化SDS的字符串**增长**操作，如果对SDS进行修改之后，SDS的长度（也即是len的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间（结构图中的sdsavail）。


alloc = len * 2


而当SDS的长度将大于等于1MB，那么程序会直接分配1MB的未使用空间，避免浪费。


alloc = len + 1MB

这样的话当字符串增长的长度没有超过未使用的空间，就可以直接进行修改而不用重新分配内存了。注意，由于空字符`'\0'`也占一字节长度，`buf`的实际长度为`alloc + 1`。

###### 2）惰性空间释放

惰性空间释放用于优化SDS的字符串**缩短**操作，当需要缩短SDS保存的字符串时，Redis并不
立即使用内存重分配来回收缩短后多出来的字节。多出来的长度被记录到`alloc`，等待被使用或在合适的时机释放。

##### 二进制安全

C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能
包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

使用SDS来保存之前提到的特殊数据格式就没有任何问题，因为SDS使用`len`属性的值而不是空
字符来判断字符串是否结束。

那么SDS为什么还要遵循以空字符结尾的规则呢？

##### 兼容部分C字符串函数

因为SDS遵循C字符串以空字符结尾的惯例：数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，所以的SDS可以重用一部分<string.h>库定义的函数。这样避免了重复造轮子，去实现字符串对比之类的函数了。

##### 总结

C字符串虽然简单高效，但是在特定情况下也存在安全和性能问题。Redis通过封装SDS解决了这些问题。分析Redis解决这些问题的方法，也可以获取一定的启发，比如针对应用场景做优化，适当预留资源，在不破坏整体功能的情况遵循惯例来提高兼容性。

