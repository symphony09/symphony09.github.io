{"title":"Redis（一）：SDS","uid":"f3d0b05742076b1a6be5180a2d1e28f1","slug":"redis1","date":"2021-03-05T08:24:45.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/redis1.json","keywords":null,"cover":[],"content":"<span id=\"more\"></span>\n\n<p>Redis 是 C 语言实现的，但是 Redis 放弃了 C 语言传统的字符串而是自己创建了一种名为}简单动态字符串 SDS（Simple Dynamic String）的抽象类型，并将 SDS 用作 Redis 的默认字符串表示，其主要原因就是传统的字符串表示方式并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求。先来看看SDS长什么样吧</p>\n<h5 id=\"SDS-数据结构示意图：\"><a href=\"#SDS-数据结构示意图：\" class=\"headerlink\" title=\"SDS 数据结构示意图：\"></a>SDS 数据结构示意图：</h5><p><img src=\"/images/host/redis/redis-sds.png\" alt=\"sds结构示意图\"></p>\n<p>可以看到字符串<code>&quot;redis&quot;</code>以字符数组的形式存放在了<code>buf</code>中，空字符<code>&#39;\\0&#39;</code>表示字符串结尾，这一点和C语言的字符串是一样的。而多出来的<code>len</code>，<code>alloc</code>，<code>flags</code>让SDS<strong>更安全、性能更好、功能性更强</strong>，具体来说就是：</p>\n<ol>\n<li><strong>可以常数复杂度获取字符串长度</strong>。</li>\n<li><strong>杜绝缓冲区溢出。</strong></li>\n<li><strong>减少修改字符串长度时所需的内存重分配次数。</strong></li>\n<li><strong>二进制安全。</strong></li>\n<li><strong>兼容部分C字符串函数。</strong></li>\n</ol>\n<p>下面就来逐条分析SDS是怎么做到这几点的。</p>\n<h5 id=\"一、-常数复杂度获取字符串长度\"><a href=\"#一、-常数复杂度获取字符串长度\" class=\"headerlink\" title=\"一、 常数复杂度获取字符串长度\"></a>一、 常数复杂度获取字符串长度</h5><p>C语言字符串没有记录自身的长度信息，所以要获取字符串长度时，就要从头开始挨个读字符，直到读取到意味着结尾的空字符<code>&#39;\\0&#39;</code>, 复杂度为**O(n)<strong>。而SDS把长度信息记录在了<code>len</code>字段，需要获取字符串长度时直接读<code>len</code>的值就OK了，复杂度降到了</strong>O(1)**。</p>\n<h5 id=\"二、-杜绝缓冲区溢出\"><a href=\"#二、-杜绝缓冲区溢出\" class=\"headerlink\" title=\"二、 杜绝缓冲区溢出\"></a>二、 杜绝缓冲区溢出</h5><p>缓冲区溢出（buffer overflow）是指当程序将数据写入缓冲区并且数据过长时，会超过缓冲区的边界，并覆盖相邻的内存位置而造成的异常。C字符串会有缓冲区溢出的风险同样是因为没有记录自身长度，不会自动进行边界检查。而SDS就不会粗暴地把大象塞进冰箱。</p>\n<p>当SDS要进行修改时，Redis首先会检查SDS的空间是否满足修改所需的要求，如果不满足的话，就会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。</p>\n<h5 id=\"三、减小修改字符串长度时所需的内存重分配次数\"><a href=\"#三、减小修改字符串长度时所需的内存重分配次数\" class=\"headerlink\" title=\"三、减小修改字符串长度时所需的内存重分配次数\"></a>三、减小修改字符串长度时所需的内存重分配次数</h5><p>上一节提到SDS会视情况扩展空间，这涉及到了重新分配内存，然而频繁分配内存会显著影响性能，这可不行。SDS通过空间预分配和惰性空间释放两种优化策略减小修改字符串长度时所需的内存重分配次数。</p>\n<h6 id=\"1）空间预分配\"><a href=\"#1）空间预分配\" class=\"headerlink\" title=\"1）空间预分配\"></a>1）空间预分配</h6><p>空间预分配用于优化SDS的字符串<strong>增长</strong>操作，如果对SDS进行修改之后，SDS的长度（也即是len的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间（结构图中的sdsavail）。</p>\n<p>alloc = len * 2</p>\n<p>而当SDS的长度将大于等于1MB，那么程序会直接分配1MB的未使用空间，避免浪费。</p>\n<p>alloc = len + 1MB</p>\n<p>这样的话当字符串增长的长度没有超过未使用的空间，就可以直接进行修改而不用重新分配内存了。注意，由于空字符<code>&#39;\\0&#39;</code>也占一字节长度，<code>buf</code>的实际长度为<code>alloc + 1</code>。</p>\n<h6 id=\"2）惰性空间释放\"><a href=\"#2）惰性空间释放\" class=\"headerlink\" title=\"2）惰性空间释放\"></a>2）惰性空间释放</h6><p>惰性空间释放用于优化SDS的字符串<strong>缩短</strong>操作，当需要缩短SDS保存的字符串时，Redis并不<br>立即使用内存重分配来回收缩短后多出来的字节。多出来的长度被记录到<code>alloc</code>，等待被使用或在合适的时机释放。</p>\n<h5 id=\"二进制安全\"><a href=\"#二进制安全\" class=\"headerlink\" title=\"二进制安全\"></a>二进制安全</h5><p>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能<br>包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>\n<p>使用SDS来保存之前提到的特殊数据格式就没有任何问题，因为SDS使用<code>len</code>属性的值而不是空<br>字符来判断字符串是否结束。</p>\n<p>那么SDS为什么还要遵循以空字符结尾的规则呢？</p>\n<h5 id=\"兼容部分C字符串函数\"><a href=\"#兼容部分C字符串函数\" class=\"headerlink\" title=\"兼容部分C字符串函数\"></a>兼容部分C字符串函数</h5><p>因为SDS遵循C字符串以空字符结尾的惯例：数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，所以的SDS可以重用一部分&lt;string.h&gt;库定义的函数。这样避免了重复造轮子，去实现字符串对比之类的函数了。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>C字符串虽然简单高效，但是在特定情况下也存在安全和性能问题。Redis通过封装SDS解决了这些问题。分析Redis解决这些问题的方法，也可以获取一定的启发，比如针对应用场景做优化，适当预留资源，在不破坏整体功能的情况遵循惯例来提高兼容性。</p>\n","text":" Redis 是 C 语言实现的，但是 Redis 放弃了 C 语言传统的字符串而是自己创建了一种名为}简单动态字符串 SDS（Simple Dynamic String）的抽象类型，并将 SDS 用作 Redis 的默认字符串表示，其主要原因就是传统的字符串表示方式并不能满足 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"Redis","slug":"学习笔记/Redis","count":5,"path":"api/categories/学习笔记/Redis.json"}],"tags":[{"name":"Redis数据结构与对象","slug":"Redis数据结构与对象","count":5,"path":"api/tags/Redis数据结构与对象.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#SDS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%9A\"><span class=\"toc-text\">SDS 数据结构示意图：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81-%E5%B8%B8%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6\"><span class=\"toc-text\">一、 常数复杂度获取字符串长度</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81-%E6%9D%9C%E7%BB%9D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">二、 杜绝缓冲区溢出</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%87%8F%E5%B0%8F%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E6%97%B6%E6%89%80%E9%9C%80%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8D%E5%88%86%E9%85%8D%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">三、减小修改字符串长度时所需的内存重分配次数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E7%A9%BA%E9%97%B4%E9%A2%84%E5%88%86%E9%85%8D\"><span class=\"toc-text\">1）空间预分配</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E6%83%B0%E6%80%A7%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">2）惰性空间释放</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">二进制安全</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%BC%E5%AE%B9%E9%83%A8%E5%88%86C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">兼容部分C字符串函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis（二）：链表","uid":"46dc18036d332e4e6512d9692f74910b","slug":"redis2","date":"2021-03-09T04:13:45.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/redis2.json","keywords":null,"cover":[],"text":" 链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。直接看结构示意图： 特征总结如下： 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。 无环：表头节点的prev指针和表尾节点的next指针都指向NU...","link":"","photos":[],"count_time":{"symbolsCount":470,"symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"Redis","slug":"学习笔记/Redis","count":5,"path":"api/categories/学习笔记/Redis.json"}],"tags":[{"name":"Redis数据结构与对象","slug":"Redis数据结构与对象","count":5,"path":"api/tags/Redis数据结构与对象.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}