{"title":"Redis（四）：跳跃表","uid":"b7745da1129b3624e0119421c5f639dd","slug":"redis4","date":"2021-03-11T05:26:55.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/redis4.json","keywords":null,"cover":[],"content":"<span id=\"more\"></span>\n\n<p>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，而且实现还更加简单。</p>\n<h5 id=\"跳跃表结构解析\"><a href=\"#跳跃表结构解析\" class=\"headerlink\" title=\"跳跃表结构解析\"></a>跳跃表结构解析</h5><p><img src=\"/images/host/redis/redis-zskip.jpg\" alt=\"跳跃表结构示意图\"></p>\n<ul>\n<li><p><code>header</code>：指向跳跃表的表头节点。</p>\n</li>\n<li><p><code>tail</code>：指向跳跃表的表尾节点。</p>\n</li>\n<li><p><code>level</code>：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</p>\n</li>\n<li><p><code>length</code>：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</p>\n</li>\n</ul>\n<p>首先要注意的是跳表是有序的，从结构示意图中可以看到节点按<code>score</code>（即图中的1.0、2.0、3.0）从小到大排列，离表头越远，<code>score</code>越大。</p>\n<p>重点是节点的结构，节点包含的属性可以分为两部分讲，一部分用来跳跃，一部分用来保存对象。</p>\n<p>跳跃可以按方向分为两种：向表尾跳和向表头跳，分别通过<strong>层</strong>和<strong>后退指针</strong>完成。</p>\n<p>结构示意图中L1、L2、L3 …代表的就是层，可以看到一个节点的层不止一个，高层跳的远（跨度大），低层跳的近（跨度小）。而后退指针只有一个（图中的BW），所以只能以固定的跨度1向表头跳。</p>\n<h6 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h6><p>以升序表为例，查找节点的流程如下：</p>\n<ol>\n<li><p>找到表头节点顶层</p>\n</li>\n<li><p>比较当前层下一节点（层指针指向的节点）和目标节点</p>\n<ul>\n<li>如果相等，找到节点，流程结束</li>\n<li>如果小于目标节点，那么跳到下一节点的当前层，重复步骤2</li>\n<li>如果大于目标节点或者到了表尾（指向null），那么跳到当前节点的下一层，重复步骤2</li>\n</ul>\n</li>\n</ol>\n<p>如果无法再重复步骤2还没找到节点，说明节点不存在。要注意的是由于Redis允许重复的score值，所以进行对比操作时，不仅要检查 score 值，还要检查 member域。</p>\n<p>查找节点的复杂度平均**O(logN)<strong>，最坏</strong>O(N)**。</p>\n<h5 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h5><ol>\n<li>找到要插入的位置，为其插入第一层。</li>\n<li>通过指定的概率p和随机算法确定是否插入第N层，N不大于最大层数，默认32。</li>\n</ol>\n<p>如果概率p为0.5，那么可以用抛硬币来类比这个过程，如果是正面插入一层，然后再抛，否则退出。</p>\n<p>可以推导出如果p越大，那么高层节点越多，查找节点越快，占用空间越多。</p>\n<p>插入新节点复杂度平均 <strong>O(logN)<strong>，最坏</strong>O(N)</strong> 。</p>\n<h5 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h5><p>相比之下，删除节点操作较为简单，和单链表删除节点所做操作大体相同。删除节点的复杂度也是平均 **O(logN)<strong>，最坏</strong>O(N)<strong>。删除分为内节点复杂度为</strong>O(N)**，N为删除节点数量。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>redis跳跃表以一种较为简单的方式实现和平衡树相同的效率，基本原理是建立一些“捷径”，免于逐节点比对。但是由于捷径是随机产生的，稳定性上还是不如平衡树。</p>\n","text":" 跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，而且实现还更加简单。 跳跃表结构解析 header：指向跳跃表的表头节点。 tail：指向跳跃表的表尾节点。 level：记录目前跳跃...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"Redis","slug":"学习笔记/Redis","count":5,"path":"api/categories/学习笔记/Redis.json"}],"tags":[{"name":"Redis数据结构与对象","slug":"Redis数据结构与对象","count":5,"path":"api/tags/Redis数据结构与对象.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">跳跃表结构解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">查找节点</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">插入节点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">删除节点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis（五）：整数集合","uid":"9661b4a0c78c3413d585a5b60f2d0c10","slug":"redis5","date":"2021-03-12T05:47:30.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/redis5.json","keywords":null,"cover":[],"text":" 整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。 整数集合结构示意图 encoding属性的值表示底层数组的整数类型。 length属性的值表示数组的...","link":"","photos":[],"count_time":{"symbolsCount":562,"symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"Redis","slug":"学习笔记/Redis","count":5,"path":"api/categories/学习笔记/Redis.json"}],"tags":[{"name":"Redis数据结构与对象","slug":"Redis数据结构与对象","count":5,"path":"api/tags/Redis数据结构与对象.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis（三）：字典","uid":"f9b13b980458a49d4d916f8fb1d54566","slug":"redis3","date":"2021-03-09T05:11:45.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/redis3.json","keywords":null,"cover":[],"text":" 字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。 字典结构解析Redis的字典使用哈希表作为底层实现，结构如图： table属性是一个数组，数组中的每个元素都是一个指向dict.h/...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"Redis","slug":"学习笔记/Redis","count":5,"path":"api/categories/学习笔记/Redis.json"}],"tags":[{"name":"Redis数据结构与对象","slug":"Redis数据结构与对象","count":5,"path":"api/tags/Redis数据结构与对象.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}