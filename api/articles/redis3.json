{"title":"Redis（三）：字典","uid":"f9b13b980458a49d4d916f8fb1d54566","slug":"redis3","date":"2021-03-09T05:11:45.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/redis3.json","keywords":null,"cover":[],"content":"<span id=\"more\"></span>\n\n<p><strong>字典</strong>在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p>\n<h5 id=\"字典结构解析\"><a href=\"#字典结构解析\" class=\"headerlink\" title=\"字典结构解析\"></a>字典结构解析</h5><p>Redis的字典使用哈希表作为底层实现，结构如图：</p>\n<p><img src=\"/images/host/redis/redis-ht.png\" alt=\"字典结构示意图\"></p>\n<p><code>table</code>属性是一个数组，数组中的每个元素都是一个指向<code>dict.h/dictEntry</code>结构的指针，每个<code>dictEntry</code>结构保存着一个键值对。<code>size</code>属性记录了哈希表的大小，也即是<code>table</code>数组的大小，而<code>used</code>属性则记录了哈希表目前已有节点（键值对）的数量。<code>sizemask</code>属性的值总是等于<code>size-1</code>，这个属性和哈希值一起决定一个键应该被放到<code>table</code>数组的哪个索引上面。</p>\n<p>index = hash &amp; sizemask;</p>\n<p>其中hash是对key进行哈希运算得出的。</p>\n<h5 id=\"解决键冲突\"><a href=\"#解决键冲突\" class=\"headerlink\" title=\"解决键冲突\"></a>解决键冲突</h5><p>当出现两个键值对计算出的索引值index相同即发生键冲突时，Redis通过链地址法来解决冲突，索引值相同的键值对通过next指针以单向链表的形式连接在一起。</p>\n<p>要注意的一点是由于没有表尾指针，出于速度考虑，新节点直接插入表头，所以插入节点的复杂度为**O(1)**。</p>\n<h5 id=\"rehash（重新散列）\"><a href=\"#rehash（重新散列）\" class=\"headerlink\" title=\"rehash（重新散列）\"></a>rehash（重新散列）</h5><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成。</p>\n<p>这个过程类似于搬家，所以会有旧房子ht[0]和新房子ht[1]，首先要判断是否需要搬家，通过公式计算负载因子：</p>\n<p>load_factor = ht[0].used / ht[0].size</p>\n<h6 id=\"满足以下条件时执行扩展操作\"><a href=\"#满足以下条件时执行扩展操作\" class=\"headerlink\" title=\"满足以下条件时执行扩展操作\"></a>满足以下条件时执行扩展操作</h6><p>1）服务器目前没有在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子大于等于1</strong>。</p>\n<p>2）服务器目前正在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子大于等于5</strong>。</p>\n<p>满足<strong>负载因子小于0.1</strong>时执行收缩操作。</p>\n<h6 id=\"rehash具体操作步骤：\"><a href=\"#rehash具体操作步骤：\" class=\"headerlink\" title=\"rehash具体操作步骤：\"></a>rehash具体操作步骤：</h6><ol>\n<li><p>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：</p>\n<ul>\n<li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2的n次方幂；</li>\n<li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2的n次方幂。</li>\n</ul>\n</li>\n<li><p>在字典中维持一个索引计数器变量rehashidx，并将它的值<strong>设置为0</strong>，表示rehash工作正式开始。</p>\n</li>\n<li><p>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序<strong>将rehashidx属性的值增一</strong>。</p>\n</li>\n<li><p>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序<strong>将rehashidx属性的值设为-1</strong>，表示rehash操作已完成。</p>\n</li>\n<li><p>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p>\n</li>\n</ol>\n<p>这种渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</p>\n<p>缺点是因为同时有两张表保存数据，数据访问操作可能需要进行两次才能完成。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。本文介绍了Redis字典的底层实现，包括如何计算索引，解决键冲突和rehash。渐进式的rehash让我印象最深，这种大而化小的解决思路值得学习。</p>\n","text":" 字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。 字典结构解析Redis的字典使用哈希表作为底层实现，结构如图： table属性是一个数组，数组中的每个元素都是一个指向dict.h/...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"Redis","slug":"学习笔记/Redis","count":5,"path":"api/categories/学习笔记/Redis.json"}],"tags":[{"name":"Redis数据结构与对象","slug":"Redis数据结构与对象","count":5,"path":"api/tags/Redis数据结构与对象.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AD%97%E5%85%B8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">字典结构解析</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E9%94%AE%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">解决键冲突</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#rehash%EF%BC%88%E9%87%8D%E6%96%B0%E6%95%A3%E5%88%97%EF%BC%89\"><span class=\"toc-text\">rehash（重新散列）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%BB%A1%E8%B6%B3%E4%BB%A5%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">满足以下条件时执行扩展操作</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#rehash%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A\"><span class=\"toc-text\">rehash具体操作步骤：</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis（四）：跳跃表","uid":"b7745da1129b3624e0119421c5f639dd","slug":"redis4","date":"2021-03-11T05:26:55.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/redis4.json","keywords":null,"cover":[],"text":" 跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，而且实现还更加简单。 跳跃表结构解析 header：指向跳跃表的表头节点。 tail：指向跳跃表的表尾节点。 level：记录目前跳跃...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"Redis","slug":"学习笔记/Redis","count":5,"path":"api/categories/学习笔记/Redis.json"}],"tags":[{"name":"Redis数据结构与对象","slug":"Redis数据结构与对象","count":5,"path":"api/tags/Redis数据结构与对象.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis（二）：链表","uid":"46dc18036d332e4e6512d9692f74910b","slug":"redis2","date":"2021-03-09T04:13:45.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/redis2.json","keywords":null,"cover":[],"text":" 链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。直接看结构示意图： 特征总结如下： 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。 无环：表头节点的prev指针和表尾节点的next指针都指向NU...","link":"","photos":[],"count_time":{"symbolsCount":470,"symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"Redis","slug":"学习笔记/Redis","count":5,"path":"api/categories/学习笔记/Redis.json"}],"tags":[{"name":"Redis数据结构与对象","slug":"Redis数据结构与对象","count":5,"path":"api/tags/Redis数据结构与对象.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}