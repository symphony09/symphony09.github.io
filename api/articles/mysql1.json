{"title":"MySQL：redo 和 undo","uid":"30e17c6fd6cc1b89b9fcc4be10f9ed75","slug":"mysql1","date":"2021-04-27T04:55:29.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/mysql1.json","keywords":null,"cover":null,"content":"<span id=\"more\"></span>\n\n<h3 id=\"redo-log-作用\"><a href=\"#redo-log-作用\" class=\"headerlink\" title=\"redo log 作用\"></a>redo log 作用</h3><p>redo log 用以保证事务的持久性，当数据库突然宕机后重启就需要使用 redo log 恢复已经提交但是没来得及同步到磁盘上的事务。</p>\n<p>再深挖一下为什么数据库宕机重启就需要恢复数据呢，这是因为直接将修改的数据页同步到磁盘意味着频繁的随机写入操作。懂点磁盘运行原理的同学都应该知道这样效率多低，但一直放在内存而不实时刷盘又容易丢失数据。 redo log 就可以解决这个问题，虽然也需要同步到磁盘，但是由于采取顺序写入的方式，所以同时具有效率高和不易失的优点。</p>\n<p>这样一来，数据库就可以从容地将修改的数据页写入磁盘而不用怕突然宕机，因为可以根据 redo log 进行恢复。</p>\n<h3 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h3><p>在InnoDB中通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须将重做日志缓冲写入重做日志文件后才算提交成功。这样就能保证成功提交的事务都被记录了下来，但是也不是绝对，后面再讲。</p>\n<p><strong>两阶段提交</strong></p>\n<p>这个与MySQL的binlog有关，binlog是MySQL Server层实现的，主要用于数据备份恢复和主从复制。为了保证两份日志的逻辑一致性MySQL采用了两阶段提交，提交过程可简略表示为：</p>\n<p>写redo log （第一阶段：prepare）-&gt;  写binlog -&gt; 写redo log (第二阶段：commit)</p>\n<p>恢复策略可简略表示为：</p>\n<ul>\n<li><p>如果redo log显示处于commit状态，说明redo log和binlog均已记录了事务，则直接提交事务</p>\n</li>\n<li><p>如果redo log显示处于prepare状态，还要看binlog是否记录了完整的事务，如果是那么就提交，否则就回滚事务</p>\n</li>\n</ul>\n<p>这样可以保证直接通过redo log恢复的数据库和通过binlog恢复或者说同步的（从）数据库一致</p>\n<p><strong>组提交</strong></p>\n<p>虽然redo log是顺序写入比随机写入快不少，但总归还是会被内存缓冲的写入速度降维打击。组提交就是用来解决这个瓶颈的，简单来说就将多个事务的写入的重做日志缓冲一次性同步到硬盘。</p>\n<p>但是开启binlog后，binlog也有这个瓶颈，并且由于要保持两份日志的一性使得redo log组提交也废了（需要加锁以同步提交顺序和写入顺序，从而导致其他事务无法提交）。于是乎binlog也搞了个组提交，称为BLGC，就是binlog组提交的首字母缩写。</p>\n<p>BLGC分为三个阶段：</p>\n<ol>\n<li>flush阶段，将binlog写入内存</li>\n<li>sync，一次性将多个事务的binlog刷新到磁盘（与redo log组提交同理，提高了效率）</li>\n<li>commit阶段，按顺序完成事务的提交</li>\n</ol>\n<p>最精华的就是最后按顺序完成事务的提交，MySQL将要提交的事务按顺序放入一个队列，队列中的第一个事务称为leader，其他事务称为follower，在最后阶段leader按顺序调用InnoDB事务的提交。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>如果数据页已经同步到了磁盘（通过LSN判断），真正持久化了，那么对应的 redo log 也就没用了。所以 redo log 有用的往往只有最新的一小段，于是可以采用循环写的方式，整体所占空间是固定的。</p>\n<p>redo log的存储都是以 块(block) 为单位进行存储的，每个块的大小为512字节。同磁盘扇区大小一致，可以保证块的写入是原子操作。</p>\n<h3 id=\"参数调优\"><a href=\"#参数调优\" class=\"headerlink\" title=\"参数调优\"></a>参数调优</h3><p><code>innodb_flush_log_at_trx_commit</code>这个参数决定了将redo log缓存刷入磁盘的时机，默认为1，代表提交时立即刷入，0代表交给master thread完成，而master thread每一秒刷入1次，2代表写入文件系统缓存，刷入交给操作系统完成。可以将参数修改为0或2提高数据库性能，但是会失去事物的ACID特性。</p>\n<h3 id=\"undo-log-的作用\"><a href=\"#undo-log-的作用\" class=\"headerlink\" title=\"undo log 的作用\"></a>undo log 的作用</h3><p>undo log的作用有两个：1. 回滚事务。2. 实现MVCC（这个有空另写一篇）</p>\n<h3 id=\"工作机制-1\"><a href=\"#工作机制-1\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h3><p>undo log是逻辑日志，所以进行的是逻辑上的反向操作，插入一条数据就删除一条数据，更新一条数据就反向更新一条数据。由于同时其他事务，并不能保证数据和原来一模一样，因此不能理解成让数据库回到某一状态。</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>由于undo log也需要持久化，所以undo log会产生redo log</p>\n<p>事务提交后不能马上删除undo log，因为在MVCC还可能用的到。最后删除时记录还会寻找同一数据页中寻找其他可以删除的记录，这是为了避免随机读写。</p>\n<h3 id=\"参数调优-1\"><a href=\"#参数调优-1\" class=\"headerlink\" title=\"参数调优\"></a>参数调优</h3><p><code>innodb_purge_batch_size</code>可以设置每次purge要清理的undo page数量。参数越大则回收的页越多，磁盘空间和分配开销越小，CPU和磁盘IO开销越大。</p>\n","text":" redo log 作用redo log 用以保证事务的持久性，当数据库突然宕机后重启就需要使用 redo log 恢复已经提交但是没来得及同步到磁盘上的事务。 再深挖一下为什么数据库宕机重启就需要恢复数据呢，这是因为直接将修改的数据页同步到磁盘意味着频繁的随机写入操作。懂点磁盘...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"MySQL","slug":"学习笔记/MySQL","count":1,"path":"api/categories/学习笔记/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"},{"name":"事务","slug":"事务","count":1,"path":"api/tags/事务.json"},{"name":"调优","slug":"调优","count":1,"path":"api/tags/调优.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#redo-log-%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">redo log 作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">工作机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">参数调优</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#undo-log-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">undo log 的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-1\"><span class=\"toc-text\">工作机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9-1\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98-1\"><span class=\"toc-text\">参数调优</span></a></li></ol>","author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MySQL：MVCC","uid":"3b8d2c61522914168806280ffb0906e3","slug":"mysql2","date":"2021-05-05T05:30:02.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/mysql2.json","keywords":null,"cover":null,"text":" 实现原理innoDB的行记录格式中有6字节事务ID的和7字节的回滚指针，通过为每一行记录添加这两个额外的隐藏值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件...","link":"","photos":[],"count_time":{"symbolsCount":945,"symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"mysql","slug":"学习笔记/mysql","count":1,"path":"api/categories/学习笔记/mysql.json"}],"tags":[{"name":"mysql实现原理","slug":"mysql实现原理","count":1,"path":"api/tags/mysql实现原理.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"TCP：序列号与滑动窗口","uid":"dcd5fd0682cc948a30be92bebe89ab9a","slug":"network2","date":"2021-04-20T05:40:26.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/network2.json","keywords":null,"cover":null,"text":" 序列号的作用上一篇博客中提到了序列号在建立tcp连接中的作用。不光如此，序列号还是tcp可靠传输的基础。 为了可靠传输就要防止丢包，所以接受端需要向发送端确认，就像我们收到快递包裹也要确认收货。类比来讲，序列号就像是快递单号。 但是与现实不同的是，tcp包数量庞大。这就造成： ...","link":"","photos":[],"count_time":{"symbolsCount":610,"symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"网络","slug":"学习笔记/网络","count":2,"path":"api/categories/学习笔记/网络.json"}],"tags":[{"name":"tcp","slug":"tcp","count":2,"path":"api/tags/tcp.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}