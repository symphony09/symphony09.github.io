{"title":"Golang最佳实践：Functional Option","uid":"7d914a4575876c2b19b68d691e332d41","slug":"go-option","date":"2021-06-29T03:38:41.000Z","updated":"2021-06-29T17:41:23.147Z","comments":true,"path":"api/articles/go-option.json","keywords":null,"cover":"https://w.wallhaven.cc/full/y8/wallhaven-y85ojk.png","content":"<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>在初始化结构体时常常会碰到这样的情况，一些字段是不能为空且没有默认值，一些字段是不能为空但有默认值，还有的的则可以为空。</p>\n<p>举例来说，有这么一个结构体</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Pool struct &#123;\n\tCapacity       int32\n\tExpiryDuration time.Duration\n\tLogger         Logger\n&#125;</code></pre>\n\n<ul>\n<li><p><code>Capacity</code>表示池容量，不能为空且没有默认值（可以有，这里只是假设）</p>\n</li>\n<li><p><code>ExpiryDuration</code>表示过期时间间隔，不能为空但有默认值</p>\n</li>\n<li><p><code>Logger</code>表示日志，可以为空</p>\n</li>\n</ul>\n<p>在这种情况下，由于需要使用默认值，所以直接用字面量初始化是不合适的。一般做法是提供初始化函数，比如如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func NewDefaultPool(cap int32) (*Pool,error) &#123;...&#125;\n\nfunc NewPoolWithLogger(cap int32, logger Logger) (*Pool, error) &#123;...&#125;</code></pre>\n\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>比较繁琐，并且因为go不支持重载，所以还得使用不同的函数名。</p>\n<h2 id=\"解决方案一：Config\"><a href=\"#解决方案一：Config\" class=\"headerlink\" title=\"解决方案一：Config\"></a>解决方案一：Config</h2><h3 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h3><p>把可选配置（有默认值或可以为空）的字段提到单独的结构体里</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Config struct &#123;\n\tExpiryDuration time.Duration\n\tLogger         Logger\n&#125;</code></pre>\n\n<p>然后提供一个初始化函数</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func NewPool(cap int32, conf *Config) (*Pool, error) &#123;...&#125;</code></pre>\n\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>这是比较常见的做法，但是需要额外的结构体，并且要判断<code>Config</code>是否为<code>nil</code></p>\n<h2 id=\"解决方案二：Builder\"><a href=\"#解决方案二：Builder\" class=\"headerlink\" title=\"解决方案二：Builder\"></a>解决方案二：Builder</h2><h3 id=\"做法-1\"><a href=\"#做法-1\" class=\"headerlink\" title=\"做法\"></a>做法</h3><p>把结构体包装为一个<code>Builder</code></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type PoolBuilder struct &#123;\n    Pool *Pool\n    Err  error\n&#125;\n\nfunc (pb *PoolBuilder) Create(cap int32) *PoolBUilder &#123;...&#125;\n\nfunc (pb *PoolBuilder) WithLogger(logger Logger) *PoolBUilder &#123;...&#125;\n\nfunc (pb *PoolBuilder) Build() (*Pool, error)</code></pre>\n\n<p>然后通过链式调用构造结构体</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">pb :&#x3D; &amp;PoolBuilder&#123;&#125;\np, err :&#x3D; pb.Create(100).WithLogger(logger).Build()</code></pre>\n\n<h3 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>这样还是需要额外的结构体，如果直接为<code>Pool</code>实现方法，无法很好进行错误处理</p>\n<h2 id=\"最佳实践：Functional-Options\"><a href=\"#最佳实践：Functional-Options\" class=\"headerlink\" title=\"最佳实践：Functional Options\"></a>最佳实践：Functional Options</h2><h3 id=\"做法-2\"><a href=\"#做法-2\" class=\"headerlink\" title=\"做法\"></a>做法</h3><p>首先声明一个函数类型</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Option func(*Pool)</code></pre>\n\n<p>然后声明一组函数</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func WithExpiryDuration(t time.Duration) Option &#123;\n    return func(p *Pool) &#123;\n        p.ExpiryDuration &#x3D; t\n    &#125;\n&#125;\n\nfunc WithLogger(logger Logger) Option &#123;\n    return func(p *Pool) &#123;\n        p.Logger &#x3D; logger\n    &#125;\n&#125;\n\nfunc NewPool(cap int32, options ...func(*Pool)) (*Pool, error) &#123;\n    p :&#x3D; &amp;Pool&#123;\n        Capacity: \t\tcap\n        ExpiryDuration: time.Hour &#x2F;&#x2F;默认值\n    &#125;\n    \n    for _, option :&#x3D; range options &#123;\n        option(p)\n    &#125;\n    \n    &#x2F;&#x2F;...\n    \n    return p, nil\n&#125;</code></pre>\n\n<p>最后构造方式如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">p, err :&#x3D; NewPool(100, WithLogger(Logger))</code></pre>\n\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>直觉式的编程</li>\n<li>高度的可配置化</li>\n<li>很容易维护和扩展</li>\n<li>自文档</li>\n<li>对于新来的人很容易上手</li>\n<li>没有什么令人困惑的事（是nil 还是空）</li>\n</ul>\n<p>OK，吹完了，收工</p>\n","text":"使用场景在初始化结构体时常常会碰到这样的情况，一些字段是不能为空且没有默认值，一些字段是不能为空但有默认值，还有的的则可以为空。 举例来说，有这么一个结构体 type Pool struct &#123; Capacity int32 ExpiryDuration time.Du...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"编程","slug":"编程","count":4,"path":"api/categories/编程.json"}],"tags":[{"name":"golang","slug":"golang","count":5,"path":"api/tags/golang.json"},{"name":"最佳实践","slug":"最佳实践","count":2,"path":"api/tags/最佳实践.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">缺点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AConfig\"><span class=\"toc-text\">解决方案一：Config</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%9A%E6%B3%95\"><span class=\"toc-text\">做法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9-1\"><span class=\"toc-text\">缺点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9ABuilder\"><span class=\"toc-text\">解决方案二：Builder</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%9A%E6%B3%95-1\"><span class=\"toc-text\">做法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9-2\"><span class=\"toc-text\">缺点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9AFunctional-Options\"><span class=\"toc-text\">最佳实践：Functional Options</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%9A%E6%B3%95-2\"><span class=\"toc-text\">做法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">优点</span></a></li></ol></li></ol>","author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Golang内存泄露","uid":"41d158fdf8b143deea2f819f3d3b843b","slug":"go-leak","date":"2021-06-30T03:38:41.000Z","updated":"2024-06-13T14:30:24.333Z","comments":true,"path":"api/articles/go-leak.json","keywords":null,"cover":"https://w.wallhaven.cc/full/y8/wallhaven-y85ojk.png","text":"防患未然 避免引用大字符串和大切片的一小部分导致无用部分无法被回收，可以复制有用部分到新串和新切片以解除引用。对于切片，也可以将无用部分设nil。 避免因为代码设计中的一些错误而导致一些协程处于永久阻塞状态。如： 从一个永远不会有其它协程向其发送数据的通道接收数据； 向一个永远不...","link":"","photos":[],"count_time":{"symbolsCount":312,"symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":4,"path":"api/categories/编程.json"}],"tags":[{"name":"golang","slug":"golang","count":5,"path":"api/tags/golang.json"},{"name":"最佳实践","slug":"最佳实践","count":2,"path":"api/tags/最佳实践.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Golang：交叉编译","uid":"a2989562c244afbcf550859cf239a080","slug":"go1","date":"2021-05-06T03:38:41.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/go1.json","keywords":null,"cover":"https://w.wallhaven.cc/full/y8/wallhaven-y85ojk.png","text":" 什么是交叉编译交叉编译是指在一个平台上生成另一个平台上的可执行程序。 比如要在Windows系统上生成可以在Linux上运行的程序时，就需要用到交叉编译。 Golang交叉编译编译参数不同的编译参数决定了最后生成的程序能在什么平台上运行，默认为当前编译平台。 GOOS 目标平台...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"速查","slug":"速查","count":1,"path":"api/categories/速查.json"},{"name":"项目部署","slug":"速查/项目部署","count":1,"path":"api/categories/速查/项目部署.json"}],"tags":[{"name":"golang","slug":"golang","count":5,"path":"api/tags/golang.json"},{"name":"编译","slug":"编译","count":1,"path":"api/tags/编译.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}