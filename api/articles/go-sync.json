{"title":"Golang标准库：sync","uid":"4dbb2ad4d40b43ce8f2a583cb86bc39c","slug":"go-sync","date":"2021-07-04T05:35:41.000Z","updated":"2024-06-13T14:30:24.333Z","comments":true,"path":"api/articles/go-sync.json","keywords":null,"cover":"https://w.wallhaven.cc/full/y8/wallhaven-y85ojk.png","content":"<h2 id=\"sync-包\"><a href=\"#sync-包\" class=\"headerlink\" title=\"sync 包\"></a>sync 包</h2><p>​    虽然go主要通过协程和通道来完成同步，但是在某些情况下使用sync包提供的同步更加简洁和巧妙。下面列举sync包的应用场景及相应的用法和坑。</p>\n<h2 id=\"一：单例\"><a href=\"#一：单例\" class=\"headerlink\" title=\"一：单例\"></a>一：单例</h2><p>单例是经常要用到的一个编程模式，go最简单的单例实现就是使用 <code>sync.One</code></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;math&#x2F;rand&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\ntype Instance struct &#123;\n\tID int\n&#125;\n\nvar (\n\tonce     sync.Once\n\tinstance Instance\n)\n\nfunc GetInstance() Instance &#123;\n\tisNew :&#x3D; false\n\tonce.Do(func() &#123;\n\t\trand.Seed(time.Now().UnixNano())\n\t\tinstance &#x3D; Instance&#123;\n\t\t\tID: rand.Intn(100),\n\t\t&#125;\n\t\tisNew &#x3D; true\n\t&#125;)\n\tif isNew &#123;\n\t\tfmt.Printf(&quot;return new instance \\n&quot;)\n\t&#125; else &#123;\n\t\tfmt.Printf(&quot;return instance that already exist. \\n&quot;)\n\t&#125;\n\treturn instance\n&#125;\n\nfunc main() &#123;\n\tfor i :&#x3D; 1; i &lt;&#x3D; 3; i++ &#123;\n\t\tfmt.Printf(&quot;got instance: %d \\n&quot;, GetInstance().ID)\n\t&#125;\n&#125;\n</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">return new instance \ngot instance: 13 \nreturn instance that already exist. \ngot instance: 13 \nreturn instance that already exist. \ngot instance: 13</code></pre>\n\n\n\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>从结果可以看到虽然调用了多次<code> GetInstance</code>函数，得到的却始终是同一个示例。这是因为<code>once.Do</code>只会执行一次。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>不要在套娃使用同一个<code>Once</code>，会造成死锁，如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func ErrOnce() &#123;\n\tvar o sync.Once\n\to.Do(func() &#123;\n\t\to.Do(func() &#123;\n\t\t\tfmt.Println(&quot;never print&quot;)\n\t\t&#125;)\n\t&#125;)\n&#125;</code></pre>\n\n<p><code>Once</code>内有一个互斥锁，这样使用会内层无法加锁</p>\n<h2 id=\"二：并发安全\"><a href=\"#二：并发安全\" class=\"headerlink\" title=\"二：并发安全\"></a>二：并发安全</h2><p><code>sync</code>提供的互斥锁可以保证数据（比如一个map）的并发安全</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type RWMap struct &#123;\n    sync.RWMutex\n    m map[int]int\n&#125;\n\nfunc (m *RWMap) Set(k int, v int) &#123;\n    m.Lock()\n    defer m.Unlock()\n    m.m[k] &#x3D; v\n&#125;\n\n&#x2F;&#x2F;...\n</code></pre>\n\n<h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>在对数据进行读写操作前加锁，操作后解锁即可。</p>\n<p>对于<code>map</code>而言，这样实现并发安全性能不高，可以使用<code>sync.Map</code>。</p>\n<h2 id=\"三：一等多\"><a href=\"#三：一等多\" class=\"headerlink\" title=\"三：一等多\"></a>三：一等多</h2><p>如果有一个协程需要等待多个协程结束的场景，可以考虑<code>sync.WaitGroup</code></p>\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;math&#x2F;rand&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\nvar wg sync.WaitGroup\n\nfunc Work(no int) &#123;\n\trand.Seed(time.Now().UnixNano())\n\tfmt.Printf(&quot;work - %d start.\\n&quot;, no)\n\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Second)\n\tfmt.Printf(&quot;work - %d done\\n&quot;, no)\n    wg.Done() &#x2F;&#x2F; 减少一个等待个数，等同于Add(-1)\n&#125;\n\nfunc main() &#123;\n\tfor i :&#x3D; 0; i &lt; 3; i++ &#123;\n\t\twg.Add(1) &#x2F;&#x2F; 增加一个等待个数\n\t\tgo Work(i)\n\t&#125;\n\twg.Wait() &#x2F;&#x2F; 阻塞至等待个数归零，不能小于0\n&#125;</code></pre>\n\n<p>结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">work - 2 start.\nwork - 0 start.\nwork - 0 done.\nwork - 1 start.\nwork - 1 done.\nwork - 2 done.</code></pre>\n\n<h3 id=\"说明-2\"><a href=\"#说明-2\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>见注释</p>\n<h3 id=\"注意点-1\"><a href=\"#注意点-1\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>不要复制<code>WaitGroup</code>的值，而应使用指针，因为要保证所有操作在同一个<code>WaitGroup</code>上。</p>\n<h2 id=\"四：多等一\"><a href=\"#四：多等一\" class=\"headerlink\" title=\"四：多等一\"></a>四：多等一</h2><p>如果有多个协程需要等待一个协程的场景，可以考虑<code>sync.Cond</code></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\nvar (\n\tdone &#x3D; false &#x2F;&#x2F; 等待条件，由被等待的协程控制\n\tc    &#x3D; sync.NewCond(&amp;sync.Mutex&#123;&#125;)\n)\n\nfunc consume(i int) &#123;\n\tc.L.Lock() &#x2F;&#x2F; 读条件前加锁\n\tfor !done &#123;\n\t\tfmt.Printf(&quot;c - %d waiting\\n&quot;, i)\n\t\tc.Wait() &#x2F;&#x2F; 先解锁，后挂起等待被唤醒，唤醒后再加锁\n\t&#125;\n\tfmt.Printf(&quot;c - %d exit\\n&quot;, i)\n\tc.L.Unlock() &#x2F;&#x2F; 读条件后解锁\n&#125;\n\nfunc main() &#123;\n\tfor i :&#x3D; 0; i &lt; 3; i++ &#123;\n\t\tgo consume(i)\n\t&#125;\n\tfmt.Println(&quot;do something&quot;)\n\ttime.Sleep(3 * time.Second)\n\tfmt.Println(&quot;done&quot;)\n\tc.L.Lock() &#x2F;&#x2F; 写条件前加锁\n\tdone &#x3D; true\n\tc.L.Unlock()  &#x2F;&#x2F; 写条件后解锁\n\tc.Broadcast() &#x2F;&#x2F; 广播通知所有协程，协程将会抢锁读条件\n\ttime.Sleep(time.Second) &#x2F;&#x2F; 等待协程结束\n&#125;</code></pre>\n\n<p>结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">c - 0 waiting\nc - 2 waiting\nc - 1 waiting\ndo something\ndone\nc - 1 exit\nc - 2 exit\nc - 0 exit\n</code></pre>\n\n<h3 id=\"说明-3\"><a href=\"#说明-3\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>见注释，除了广播通知还可以用<code>Signal()</code>单个通知。</p>\n<p>此外通过关闭通道实现一对多通知也是非常不错的方法。</p>\n<h3 id=\"注意点-2\"><a href=\"#注意点-2\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ol>\n<li>调用<code>Wait</code>前后要加解锁，如果不加锁<code>Wait</code>内部无法解锁，如果不解锁其他协程无法加锁</li>\n<li>同样不可复制值</li>\n<li>遵循FIFO规则，即先到先出</li>\n</ol>\n","feature":true,"text":"sync 包​ 虽然go主要通过协程和通道来完成同步，但是在某些情况下使用sync包提供的同步更加简洁和巧妙。下面列举sync包的应用场景及相应的用法和坑。 一：单例单例是经常要用到的一个编程模式，go最简单的单例实现就是使用 sync.One 示例package main im...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"编程","slug":"编程","count":4,"path":"api/categories/编程.json"}],"tags":[{"name":"golang","slug":"golang","count":5,"path":"api/tags/golang.json"},{"name":"标准库","slug":"标准库","count":1,"path":"api/tags/标准库.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#sync-%E5%8C%85\"><span class=\"toc-text\">sync 包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%EF%BC%9A%E5%8D%95%E4%BE%8B\"><span class=\"toc-text\">一：单例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">注意点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">二：并发安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-1\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-1\"><span class=\"toc-text\">说明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%EF%BC%9A%E4%B8%80%E7%AD%89%E5%A4%9A\"><span class=\"toc-text\">三：一等多</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-2\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-2\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9-1\"><span class=\"toc-text\">注意点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%EF%BC%9A%E5%A4%9A%E7%AD%89%E4%B8%80\"><span class=\"toc-text\">四：多等一</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-3\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9-2\"><span class=\"toc-text\">注意点</span></a></li></ol></li></ol>","author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"NAS 折腾记","uid":"5e6bac11d8337953e8e2ec023a083948","slug":"nas1","date":"2021-07-26T03:29:41.000Z","updated":"2024-06-13T14:30:24.333Z","comments":true,"path":"api/articles/nas1.json","keywords":null,"cover":"https://w.wallhaven.cc/full/43/wallhaven-43zkod.jpg","text":"因为本人没多少money，加上喜欢折腾，所以并未采用现成的 NAS 方案，选择自己凑配硬件搭建。在21年初初步搭建完成，现在已经平稳运行半年左右，还算满意。现在得空分享一下搭建经验，供同好参考。 方案介绍不同于常见的多盘位 NAS 机箱，我采用了迷你主机加硬盘盒的形式，通过网线连...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"折腾","slug":"折腾","count":1,"path":"api/categories/折腾.json"}],"tags":[{"name":"硬件","slug":"硬件","count":2,"path":"api/tags/硬件.json"},{"name":"nas","slug":"nas","count":1,"path":"api/tags/nas.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Golang内存泄露","uid":"41d158fdf8b143deea2f819f3d3b843b","slug":"go-leak","date":"2021-06-30T03:38:41.000Z","updated":"2024-06-13T14:30:24.333Z","comments":true,"path":"api/articles/go-leak.json","keywords":null,"cover":"https://w.wallhaven.cc/full/y8/wallhaven-y85ojk.png","text":"防患未然 避免引用大字符串和大切片的一小部分导致无用部分无法被回收，可以复制有用部分到新串和新切片以解除引用。对于切片，也可以将无用部分设nil。 避免因为代码设计中的一些错误而导致一些协程处于永久阻塞状态。如： 从一个永远不会有其它协程向其发送数据的通道接收数据； 向一个永远不...","link":"","photos":[],"count_time":{"symbolsCount":312,"symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":4,"path":"api/categories/编程.json"}],"tags":[{"name":"golang","slug":"golang","count":5,"path":"api/tags/golang.json"},{"name":"最佳实践","slug":"最佳实践","count":2,"path":"api/tags/最佳实践.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}