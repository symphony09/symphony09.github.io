{"title":"MySQL：MVCC","uid":"3b8d2c61522914168806280ffb0906e3","slug":"mysql2","date":"2021-05-05T05:30:02.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/mysql2.json","keywords":null,"cover":null,"content":"<span id=\"more\"></span>\n\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>innoDB的行记录格式中有6字节事务ID的和7字节的回滚指针，通过为每一行记录添加这两个额外的隐藏值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。</p>\n<p>但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。</p>\n<p>当隔离级别是REPEATABLE READ时这种策略是如何应用到特定的操作的。</p>\n<p><strong>SELECT</strong></p>\n<p>当隔离级别是REPEATABLE READ时select操作，InnoDB必须每行数据来保证它符合两个条件：</p>\n<ol>\n<li>InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。</li>\n<li>这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。<br>符合这两个条件的行可能会被当作查询结果而返回。</li>\n</ol>\n<p><strong>INSERT</strong></p>\n<p>InnoDB为这个新行记录当前的系统版本号。</p>\n<p><strong>DELETE</strong></p>\n<p>InnoDB将当前的系统版本号设置为这一行的删除ID。</p>\n<p><strong>UPDATE</strong></p>\n<p>InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。</p>\n<p>当记录不满足SELECT的第一个条件时，就读取它的历史版本，而具有回滚作用的<code>undo log</code>就在这里用上了。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。</p>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。</p>\n","text":" 实现原理innoDB的行记录格式中有6字节事务ID的和7字节的回滚指针，通过为每一行记录添加这两个额外的隐藏值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件...","link":"","photos":[],"count_time":{"symbolsCount":945,"symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"mysql","slug":"学习笔记/mysql","count":1,"path":"api/categories/学习笔记/mysql.json"}],"tags":[{"name":"mysql实现原理","slug":"mysql实现原理","count":1,"path":"api/tags/mysql实现原理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">优缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%BC%E5%AE%B9%E6%80%A7\"><span class=\"toc-text\">兼容性</span></a></li></ol>","author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Golang：交叉编译","uid":"a2989562c244afbcf550859cf239a080","slug":"go1","date":"2021-05-06T03:38:41.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/go1.json","keywords":null,"cover":"https://w.wallhaven.cc/full/y8/wallhaven-y85ojk.png","text":" 什么是交叉编译交叉编译是指在一个平台上生成另一个平台上的可执行程序。 比如要在Windows系统上生成可以在Linux上运行的程序时，就需要用到交叉编译。 Golang交叉编译编译参数不同的编译参数决定了最后生成的程序能在什么平台上运行，默认为当前编译平台。 GOOS 目标平台...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"速查","slug":"速查","count":1,"path":"api/categories/速查.json"},{"name":"项目部署","slug":"速查/项目部署","count":1,"path":"api/categories/速查/项目部署.json"}],"tags":[{"name":"golang","slug":"golang","count":5,"path":"api/tags/golang.json"},{"name":"编译","slug":"编译","count":1,"path":"api/tags/编译.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MySQL：redo 和 undo","uid":"30e17c6fd6cc1b89b9fcc4be10f9ed75","slug":"mysql1","date":"2021-04-27T04:55:29.000Z","updated":"2024-06-13T14:30:24.333Z","comments":false,"path":"api/articles/mysql1.json","keywords":null,"cover":null,"text":" redo log 作用redo log 用以保证事务的持久性，当数据库突然宕机后重启就需要使用 redo log 恢复已经提交但是没来得及同步到磁盘上的事务。 再深挖一下为什么数据库宕机重启就需要恢复数据呢，这是因为直接将修改的数据页同步到磁盘意味着频繁的随机写入操作。懂点磁盘...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":9,"path":"api/categories/学习笔记.json"},{"name":"MySQL","slug":"学习笔记/MySQL","count":1,"path":"api/categories/学习笔记/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"},{"name":"事务","slug":"事务","count":1,"path":"api/tags/事务.json"},{"name":"调优","slug":"调优","count":1,"path":"api/tags/调优.json"}],"author":{"name":"年鲤","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"喜欢折腾，随性而为<br/>sunfish69@163.com","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}